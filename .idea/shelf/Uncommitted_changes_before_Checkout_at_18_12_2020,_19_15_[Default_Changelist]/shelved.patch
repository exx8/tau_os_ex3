Index: message_slot.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\n#include \"message_slot.h\"\n#include <linux/kernel.h>   /* We're doing kernel work */\n#include <linux/module.h>   /* Specifically, a module */\n#include <linux/fs.h>       /* for register_chrdev */\n#include <linux/string.h>\n#include \"linux/slab.h\"\n#include \"linux/uaccess.h\"\n#include <linux/spinlock.h>\n\nMODULE_LICENSE(\"GPL\");\ntypedef struct {\n    int channel_id;\n    unsigned int minor;\n} private_data_type;\ntypedef struct {\n    char msg_value[msg_len];\n    short len;\n    unsigned int channel_id;\n\n} msg;\n\nstatic int size_of_lists[channel_num];\nstatic msg **minor_arr;\n\nstatic void debug(char *const fmt) {\n    printk(KERN_ERR \"%s\", fmt);\n}\n\nstatic void debug_pointer(void *pointer) {\n    printk(KERN_ERR \"%p\", pointer);\n}\n\n/**\n *\n * @param minor\n * @param new_msg\n * @return 0 for failure 1 for success\n */\nint add2list(int minor, msg new_msg) {\n    int k;\n    void *newPlace;\n    size_of_lists[minor]++;\n    newPlace = krealloc(minor_arr, size_of_lists[minor] * sizeof(msg **), GFP_KERNEL);\n    printk(\"resize complete\");\n    if (newPlace == NULL)\n        return 0;\n\n    minor_arr[minor] = newPlace;\n    for (k = 0; k < new_msg.len; k++) {\n        minor_arr[minor][size_of_lists[minor] - 1].msg_value[k] = new_msg.msg_value[k];\n    }\n    printk(\"new_msg is %s, and arr is %s length of msg is %d\", new_msg.msg_value,\n           minor_arr[minor][size_of_lists[minor] - 1].msg_value, new_msg.len);\n    minor_arr[minor][size_of_lists[minor] - 1].channel_id = new_msg.channel_id;\n\n    minor_arr[minor][size_of_lists[minor] - 1].len = new_msg.len;\n    return 1;\n\n}\n\nstatic unsigned int get_minor(const struct inode *inode) {\n    unsigned int minor = iminor(inode);\n    return minor;\n}\n\nstatic int device_open(struct inode *inode, struct file *file) {\n    unsigned int minor;\n    private_data_type *private_data = kcalloc(sizeof(private_data), 1, GFP_KERNEL);\n    if (minor_arr == NULL)\n        minor_arr = kcalloc(sizeof(*minor_arr), channel_num, GFP_KERNEL);\n    minor = get_minor(inode);\n    printk(\"open minor %d \\n\", minor);\n    private_data->minor = minor;\n    private_data->channel_id = NO_CHANNEL;\n    file->private_data = private_data;\n\n\n    return OK;\n}\n\nstatic bool no_channel(const struct file *file) {\n    debug(\"in no channel\");\n\n    return ((private_data_type *) file->private_data)->channel_id == NO_CHANNEL;\n}\n\nstatic msg *get_entry_by_channel_id(unsigned int channel_id, unsigned minor) {\n    int i = 0;\n    printk(\"size as viewed by get_entry_by_channel_id :%d\", size_of_lists[minor]);\n    debug_pointer(minor_arr[minor]);\n    for (i = size_of_lists[minor] - 1; i >= 0; i--) {\n        msg entry = (minor_arr[minor])[i];\n        printk(\"pointer number: %d\", i);\n        printk(KERN_ERR \"premortum\");\n        printk(\"channel id as seen by get_entry_by_channel_id: %d\", entry.channel_id);\n        if (entry.channel_id == channel_id) {\n            debug(entry.msg_value);\n\n            return &minor_arr[minor][i];\n\n\n        }\n    }\n    printk(KERN_ERR \"postmortum\");\n    debug_pointer(size_of_lists);//to eliminate warnings\n    return NULL;\n}\n\nstatic ssize_t device_read(struct file *file, char __user *buffer, size_t length, loff_t *offset) {\n    unsigned int minor;\n    short i;\n    short returned;\n    msg *entry;\n    int channel_id;\n\n    debug(\"before no channel read\");\n    if (no_channel(file)) {\n        debug(\"found no channel\");\n        return -EINVAL;\n    }\n    debug(\"before reading channel_id\");\n    channel_id = ((private_data_type *) file->private_data)->channel_id;\n    minor = ((private_data_type *) file->private_data)->minor;\n    printk(\"read minor: %d\", minor);\n    entry = get_entry_by_channel_id(channel_id, minor);\n\n    if (entry == NULL) {\n        debug(\"in EWOULDBLOCK\");\n        return -EWOULDBLOCK; //resource temproray unavailable\n    }\n\n    if (entry->len > length)\n        return -ENOSPC;\n    for (i = 0; i < entry->len; i++) {\n        int put_user_status = put_user(entry->msg_value[i], &buffer[i]);\n        if (put_user_status != 0)\n            return -EINVAL;\n    }\n    returned = entry->len;\n    return returned;\n}\n\n\n//invariant: old versions always come after the most updated\nstatic ssize_t device_write(struct file *file, const char __user *buffer, size_t length, loff_t *offset) {\n    int i;\n    msg new_msg;\n    char *priv_buffer;\n    int minor;\n    int channel_id;\n    int status;\n    msg * lookup_results;\n    minor = ((private_data_type *) file->private_data)->minor;\n    printk(\"shouldn't be 0: %d\", ((private_data_type *) file->private_data)->minor);\n    if (no_channel(file))\n        return -EINVAL;\n    printk(\"is buffer NULL %d\", buffer == NULL);\n    if (buffer == NULL)\n        return -EINVAL;\n    debug(\"device write\");\n    channel_id = ((private_data_type *) file->private_data)->channel_id;\n    debug(\"device write minor\");\n    if (length == 0 || length > msg_len)\n        return -EMSGSIZE;\n\n    new_msg.channel_id = channel_id;\n    new_msg.len = length;\n    priv_buffer = new_msg.msg_value;\n    debug(\"device write before for\");\n    printk(\"%zu\", length);\n    for (i = 0; i < length; i++) {\n        int status_get_user = get_user(priv_buffer[i], &buffer[i]);\n        if (status_get_user != 0)\n            return -EINVAL;\n    }\n    lookup_results=get_entry_by_channel_id(channel_id,minor);\n    if(lookup_results==NULL) {\n        status = add2list(minor, new_msg);\n        if (!status)\n            return -ENOMEM;\n        printk(\"viewed length is :%d,status is :%d\", size_of_lists[minor], status);\n    }\n    else\n    {\n        *lookup_results=new_msg;\n\n    }\n    return i;\n}\n\nstatic long einvalid_ioctl(void) {\n    return -EINVAL;\n}\n\n\nstatic long device_ioctl(struct file *file, unsigned int ioctl_command_id, unsigned long channel) {\n    unsigned int channel_id = channel;\n    debug(\"iocntrl\\n\");\n    if (ioctl_command_id != MSG_SLOT_CHANNEL || channel == 0) {\n        return einvalid_ioctl();\n    }\n\n    ((private_data_type *) file->private_data)->channel_id = channel_id;\n\n    return OK;\n}\n\n\nstatic int device_release(struct inode *inode, struct file *file) {\n    void *private_data = file->private_data;\n    kfree(private_data);\n\n    return OK;\n\n}\n\nstruct file_operations Fops =\n        {\n                .owner      = THIS_MODULE, // Required for correct count of module usage. This prevents the module from being removed while used.\n                .read           = device_read,\n                .write          = device_write,\n                .open           = device_open,\n                .release        = device_release,\n                .unlocked_ioctl=device_ioctl\n\n        };\n\nstatic int __init simple_init(void) {\n\n    int major;\n    int status;\n    // Register driver capabilities. Obtain major num\n    printk(\"%d\", MAJOR_NUM);\n    status = register_chrdev(MAJOR_NUM, DEVICE_RANGE_NAME, &Fops);\n    major = MAJOR_NUM;\n    // Negative values signify an error\n    if (status < 0) {\n        printk(KERN_ALERT \"%s registraion failed for  %d\\n\",\n               DEVICE_FILE_NAME, major);\n        return status;\n    }\n\n    printk(\"Registeration is successful. \"\n           \"The major device number is %d.\\n\", major);\n    printk(\"If you want to talk to the device driver,\\n\");\n    printk(\"you have to create a device file:\\n\");\n    printk(\"mknod /dev/%s c %d 0\\n\", DEVICE_FILE_NAME, major);\n    printk(\"You can echo/cat to/from the device file.\\n\");\n    printk(\"Dont forget to rm the device file and \"\n           \"rmmod when you're done\\n\");\n\n    return 0;\n}\n\nstatic void __exit simple_cleanup(void) {\n    // Unregister the device\n    // Should always succeed\n    int i;\n    for (i = 0; i < channel_num; i++) {\n        kfree(minor_arr[i]);\n    }\n    kfree(minor_arr);\n    unregister_chrdev(MAJOR_NUM, DEVICE_RANGE_NAME);\n}\n\nmodule_init(simple_init);\n\nmodule_exit(simple_cleanup);
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/message_slot.c b/message_slot.c
--- a/message_slot.c	(revision 3f1fbf6b2a48df9fb23ae1393eca7ea956b7836b)
+++ b/message_slot.c	(date 1608311555032)
@@ -257,10 +257,11 @@
     // Unregister the device
     // Should always succeed
     int i;
+
     for (i = 0; i < channel_num; i++) {
         kfree(minor_arr[i]);
     }
-    kfree(minor_arr);
+ //   kfree(minor_arr);
     unregister_chrdev(MAJOR_NUM, DEVICE_RANGE_NAME);
 }
 
